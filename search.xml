<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于zookeeper的Dubbo框架搭建]]></title>
    <url>%2Fp%2F1d70d5b2%2F</url>
    <content type="text"><![CDATA[基于zookeeper的Dubbo框架搭建工具:idea 环境:jdk1.8 本文采用了Dubbo、zookeeper及spring框架整合,实现了单机zookeeper的远程方法调用 1、Dubbo的基本介绍Dubbo官方网站:http://dubbo.apache.org Dubbo是阿里巴巴在2011年开源出来基于Java的分布式远程调用框架, dubbo是基于定义服务的概念,指定可以通过参数和返回类型远程调用的方法。在服务器端,服务器实现这个接口,并运行一个dubbo服务器来处理客户端调用。在客户端,客户机有一个存根,它提供与服务器相同的方法。 简单来说,dubbo就是: 一款分布式服务框架 高性能和透明化的RPC远程服务调用方案 SOA服务治理方案 Dubbo为我们提供了三个核心功能: 基于接口的远程调用 容错和负载均衡 服务的自动注册和发现 2、Dubbo的结构 Provider: 暴露服务的服务提供方。Consumer: 调用远程服务的服务消费方。Registry: 服务注册与发现的注册中心。Monitor: 统计服务的调用次数和调用时间的监控中心。 调用流程0.服务容器负责启动，加载，运行服务提供者。1.服务提供者在启动时，向注册中心注册自己提供的服务。2.服务消费者在启动时，向注册中心订阅自己所需的服务。3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 3、Dubbo的支持的注册中心1)、Multicast注册中心Multicast 注册中心不需要启动任何中心节点，只要广播地址一样，就可以互相发现.但这种注册方式受网络结构限制,只适合小规模应用或开发阶段使用。 使用Multicast注册中心可使用的组播地址段: 224.0.0.0 - 239.255.255.255 2、zookeeper注册中心Zookeeper是Apacahe Hadoop的子项目,是一个树型的目录服务 3、Redis注册中心是一套基于redis实现的注册中心 4、Simple注册中心Simple注册中心本身就是一个普通的 Dubbo 服务,可以减少第三方依赖.使整体通讯方式一致。 在这里我们采用的是第二种也就是zookeeper注册中心 具体的注册中心介绍可以参照官网文档http://dubbo.apache.org/zh-cn/docs/user/quick-start.html 4、Dubbo的优缺点优点: 透明化的远程方法调用 像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入 软负载均衡及容错机制 可在内网替代nginx lvs等硬件负载均衡器 服务注册中心自动注册和自动发现 不需要写死服务提供者地址，注册中心基于接口名自动查询提供者IP 服务接口监控与治理 Dubbo-admin与Dubbo-monitor提供了完善的服务接口管理与监控功能,针对不同应用的不同接口,可以进行多版本,多协议,多注册中心管理 但是缺点也很明显,就是只支持Java语言 4、zookeeper注册中心1)、zookeeper结构 Root:为zookeeper的根节点 Service:注册的服务存储节点 Type:消费方和提供方的储存节点 URL:具体的url地址 流程说明： 服务提供者启动时:向/dubbo/com.foo.BarService/providers目录下写入自己的URL地址 服务消费者启动时:订阅/dubbo/com.foo.BarService/providers目录下的提供者URL地址,并向/dubbo/com.foo.BarService/consumers目录下写入自己的URL地址 监控中心启动时:订阅/dubbo/com.foo.BarService目录下的所有提供者和消费者URL地址 2)、zookeeper客户端Dubbo支持zkclient和curator两种Zookeeper客户端实现 zkclient客户端从2.2.0版本开始缺省为zkclient实现,以提升zookeeper客户端的健状性。zkclient 是 Datameer 开源的一个 Zookeeper 客户端实现. 具体配置见后面的demo curator客户端从2.3.0版本开始支持可选curator实现.Curator是Netflix开源的一个Zookeeper客户端实现 因为这里使用的是zkclient客户端,所以对于curator客户端就不做阐述了 5、zookeeper安装本文的服务器系统使用的是centOS6.7.Windows系统下的安装步骤一样,只是启动脚本改为.cmd后缀的 1)、下载与解压zookeeper官方地址http://zookeeper.apache.org/ 12wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.11/zookeeper-3.4.13.tar.gztar -zxvf zookeeper-3.4.13.tar.gz 解压完成之后会在下载的目录下多出一个zookeeper-3.4.13.tar.gz目录,cd进入这个目录 2)、zookeeper配置在任意目录创建两个文件用来存放zookeeper的数据和日志文件夹 12mkdir /usr/soft/zookeeper/datamkdir /usr/soft/zookeeper/log cd进入conf目录,拷贝zoo_sample.cfg文件为zoo.cfg.因为zookeeper启动默认加载zoo.cfg配置文件 123cd confcp cp zoo_sample.cfg zoo.cfgvim zoo.cfg 修改配置 123dataDir=/usr/soft/zookeeper/data # 数据保存路径,填写的是你之前创建的路径dataLogDir=/usr/soft/zookeeper/log # 新增日志保存路径,填写的是你之前创建的路径clientPort=2181 # 端口号,因为这里不是集群环境,所以保持默认就好 保存退出后进入到bin目录,启动zookeeper 3)、启动zookeeper12cd bin./zkServer.sh start 看到这个提示信息说明你的zookeeper启动成功了 你可以使用客户端连接zookeeper查看 1./zkCli.sh 如果连接中出现这个,直接回车就好了 连接成功之后可以输入ls /查看 出现这个说明你的zookeeper已经启动成功了 因为是在虚拟机中测试,所有想要在本机中连接上zookeeper,最简单的办法就是将虚拟机的防火墙关掉,不然会连接超时 1service iptables stop 6、Java Demo系统要求:jdk1.6以上,maven3.0以上 1)、创建maven项目项目结构: dubbo_api:服务接口 dubbo_consumer:服务消费方 dubbo_provider:服务提供方 2)、导入依赖a.在父模块中引入依赖,因为是提供方和消费方都需要的依赖,避免重复导入,所以在父模块中引入重复的依赖 12345678910111213141516171819202122232425&lt;!-- 单元测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- dubbo --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- zookeeper客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; b.服务消费方和服务提供方都需要引入dubbo_api的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.siworae&lt;/groupId&gt; &lt;artifactId&gt;dubbo_api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 3)、接口定义实现 123public interface IUserService &#123; public Integer queryUserByUserId(Integer userId);&#125; 4)、provider服务提供方实现 123456789@Servicepublic class UserServiceImpl implements IUserService &#123; @Override public Integer queryUserByUserId(Integer userId) &#123; System.out.println("收到请求,查询参数是:"+userId); return 1; &#125;&#125; 定义一个测试类,用来发布服务 1234567public class publish &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring-provider.xml"); context.start(); System.in.read(); &#125;&#125; 5)、consumer服务实现 12 6)、xml配置a.consumer消费方配置 在main下新建资源文件夹resources,新建文件spring_consumer.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!--启动包扫描--&gt; &lt;context:component-scan base-package="com.siworae"/&gt; &lt;!--应用名称--&gt; &lt;dubbo:application name="dubbo-consumer"/&gt; &lt;!--注册中心 设置为你们自己的zookeeper服务器的IP和端口--&gt; &lt;dubbo:registry address="zookeeper://192.168.230.220:2181"/&gt; &lt;!--配置订阅服务--&gt; &lt;dubbo:reference id="userService" interface="com.siworae.service.IUserService"/&gt;&lt;/beans&gt; b.provider提供方配置 在main下新建资源文件夹resources,新建文件spring_provider.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 配置包扫描 --&gt; &lt;context:component-scan base-package="com.siworae"/&gt; &lt;!-- 服务配置 注册中心 服务列表 应用名称 --&gt; &lt;!--应用名称--&gt; &lt;dubbo:application name="dubbo_provider"/&gt; &lt;!--注册中心--&gt; &lt;!--&lt;dubbo:registry address="multicast://224.5.6.7:1234"/&gt;--&gt; &lt;!--&lt;dubbo:registry address="zookeeper://127.0.0.1:2181"/&gt;--&gt; &lt;dubbo:registry address="zookeeper://192.168.230.220:2181"/&gt; &lt;!--框架协议--&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!--配置注册的服务--&gt; &lt;dubbo:service interface="com.siworae.service.IUserService" ref="userServiceImpl"/&gt;&lt;/beans&gt; 同时在provider和consumer的资源文件夹中添加log4j配置文件,不然运行会报异常 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 7)、测试在consumer新建测试类,测试是否可以调用成功,如果控制台成功打印数字”1”.则说明调用成功 12345678public class UserControllerTest &#123; public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext("spring-consumer.xml"); UserController userController = (UserController) context.getBean("userController"); Integer user = userController.queryUserByUserId(1); System.out.println(user); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在java环境中操作redis服务器]]></title>
    <url>%2Fp%2Fb5f3cf78%2F</url>
    <content type="text"><![CDATA[在java环境中操作redis服务器工具:idea 环境:jdk1.8 1、环境配置在ieda中新建maven工程,导入依赖 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 单元测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- spring测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.8.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- log4j日志打印 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt; 2、配置文件在main下面新建资源文件夹resources.在resources下新建spring配置文件spring.xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="1024"/&gt; &lt;!-- 最大 空闲连接数 --&gt; &lt;property name="maxIdle" value="200"/&gt; &lt;!-- 获取连接时最大等待毫秒数 --&gt; &lt;property name="maxWaitMillis" value="10000"/&gt; &lt;!-- 在获取连接时检查有效性 --&gt; &lt;property name="testOnBorrow" value="true"/&gt; &lt;/bean&gt; &lt;!-- 设置redis的连接 --&gt; &lt;bean id="redisSentinelConfiguration" class="org.springframework.data.redis.connection.RedisSentinelConfiguration"&gt; &lt;property name="master"&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;property name="name" value="mymaster"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 设置sentinel --&gt; &lt;property name="sentinels"&gt; &lt;set&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;!--value改为你们自己的sentinel服务器的IP和端口 --&gt; &lt;constructor-arg name="host" value="192.168.230.221"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="26379"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg name="host" value="192.168.230.221"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="26380"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg name="host" value="192.168.230.221"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="26381"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 客户端连接工厂 --&gt; &lt;bean id="jedisConnFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;!-- 连接池引用 --&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig"/&gt; &lt;constructor-arg name="sentinelConfig" ref="redisSentinelConfiguration"/&gt; &lt;!-- value改为你们自己redis服务器的访问密码 --&gt; &lt;property name="password" value="123456"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- redis模板类配置 --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" p:connection-factory-ref="jedisConnFactory"&gt; &lt;!-- 配置序列化操作,指定key值和hashkey的序列化方式 --&gt; &lt;property name="keySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;property name="hashKeySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在resources下新建log4j配置文件log4j.properties 这个配置文件基本通用,可以不用改,直接拷过去就能用了 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 3、启动项目然后我们借助spring的测试环境测试 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;"classpath:spring.xml"&#125;)public class TestSpringDataRedis &#123; @Resource(name = "redisTemplate") private ValueOperations&lt;String,Object&gt; valueOperations; @Test public void test()&#123;// valueOperations.set("a","123"); System.out.println(valueOperations.get("a")); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下redis的读写分离配置和高可用环境配置]]></title>
    <url>%2Fp%2F9227d01%2F</url>
    <content type="text"><![CDATA[Linux下redis的读写分离配置和高可用环境配置因为高可用和主备切换需要多台服务器,准备不了那么多服务器所以本文中的多台服务器是利用一台服务器的多端口模拟多台服务器实现的 redis 服务器三台 123192.168.230.221 6379(master-主服务器)192.168.230.221 6380(slave-从服务器)192.168.230.221 6381(slave-从服务器) Sentinel 哨兵服务器三台 123192.168.230.221 26379192.168.230.221 26380192.168.230.221 26381 1、redis的安装redis官方网站:http://www.redis.cn 1)、下载并解压redis进入到指定目录,这里我下载到/usr/soft/redis目录 123cd /usr/soft/rediswget http://download.redis.io/releases/redis-5.0.3.tar.gztar zxf redis-redis-5.0.3.tar.gz 解压之后redis目录下就会出现redis-5.0.3文件夹,cd进入这个文件夹, 因为redis是用C语言写的,所以在运行前需要对源码文件进行编译才能运行 如果你的系统里面已经有了GCC的编译环境,那么你可以直接编译,没有的话就需要安装GCC的编译环境进行对redis的源码进行编译, 1yum install gcc 安装成功之后就可以进行编译了,一定要在redis的根目录进行编译 1make 如果在编译过程中出现了command not found错误,则是没有安装GCC编译环境,重新安装完编译环境后一定要删除解压后的文件重新解压编译,不然会出错 编译完成后,src目录中就会出现这些可执行文件就说明你的redis服务器安装成功了 2、配置redis主服务器redis的配置文件是存放在根目录的redis.conf文件启动redis之前我们修改一些配置文件 1vim redis.conf 123456#bind 127.0.0.1 #注释此配置,允许该服务器所有IP都能访问到Redis服务port 6379 #Redis服务的端口,默认是6379。可不修改daemonize yes #以守护进程模式启动redis,这样启动之后reids就不会占用当前连接databases 16 #默认redis服务器的库数量requirepass "123456" #设置redis的访问密码masterauth "123456" #设置从服务器访问主服务器的访问密码 3、配置redis从服务器由于是单机多端口模拟多台服务器,所以需要将redis的文件夹拷贝两份 12cp -r redis-5.0.3 redis-6380cp -r redis-5.0.3 redis-6381 分别进入这两个文件夹进行配置文件修改 12cd redis-6380vim redis.conf 123456#bind 127.0.0.1 #注释此配置,允许该服务器所有IP都能访问到Redis服务port 6380 #Redis服务的端口,进入redis-6381文件夹时端口改为6381,确保端口不冲突daemonize yes #以守护进程模式启动redis,这样启动之后reids就不会占用当前连接requirepass "123456" #设置redis的访问密码masterauth "123456" #设置从服务器访问主服务器的访问密码replicaof 192.168.230.220 6379 #设置主服务器IP地址及端口 低版本的redis设置服务器的配置项是:slaveof 192.168.230.220 6379,经测试,高版本设置这个属性也可以正常连接 保存退出,然后在各个redis的根目录启动redis服务器 启动redis服务器就是执行src文件夹中redis-server.sh的可以执行文件进行启动,同时显式的指定配置文件 4、启动服务器启动主服务器 12cd redis-5.0.3src/redis-server redis.conf 启动两个从服务器 1234cd ../redis-6380src/redis-server redis.confcd ../redis-6381src/redis-server redis.conf 查看服务器启动情况 1ps -ef|grep redis 此时你的redis服务已经启动成功了,然后就可以用客户端进行连接了 接着执行客户端启动脚本,连接的时候利用-a指定密码,-p指定端口(如果是默认端口6379可不写) 1src/redis-cli -a 123456 -p 6379 当你看着这个的时候说明redis连接成功了,此时你可以在这里输入reids命令进行操作 因为客户端会占用当前连接,所以我们需要另开一个ssh连接进行从服务器的客户端连接 此时在主服务器客户端(也就是6379端口的服务器)中查看从服务器的连接情况 1info replication 此时说明两台从服务器已经连接上了主服务器了,当然你也可以在从服务器的客户端查看主服务器的情况 1info replication 123master_host:192.168.230.221 主服务器IPmaster_port:6379 主服务器端口master_link_status:up 主服务器是否在线(up为在线,down为离线) 此时redis服务器的读写分离环境已经搭建完成 主服务器读写测试 从服务器读测试,此时从服务器可以直接读取到在主服务器添加的数据, 而在从服务器添加数据,则会提示从服务器是只读的 5、准备Sentinel 哨兵服务器回到redis根目录的上一级,我的目录结构是:/usr/soft/redis/,redis目录用来存放各个redis服务器.所以回到redis目录拷贝 123cp -r redis-6379 redis-26379cp -r redis-6379 redis-26380cp -r redis-6379 redis-26381 最终你的redis文件夹应该有这六个文件,说明你的sentinel服务器已经准备好了.剩下的就是修改配置了 哨兵服务器用的配置文件和redis服务器不一样,哨兵服务器用的是sentinel.conf 依次cd进入各个文件夹修改配置文件 12cd redis-26379vim sentinel.conf 123456789port 26379 # 哨兵服务器端口# mymaster为redis主服务器别名,192.168.230.221为主服务器IP,6379为主服务器端口,2为哨兵切换主备投票的最低票# 数,计算公式为(哨兵服务器数量+1)/2sentinel monitor mymaster 192.168.230.221 6379 2sentinel auth-pass mymaster 123456 # mymaster为上面设置的别名,123456为连接主服务器需要的访问密码# sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换),则认为本次failover失败# 默认值为900000毫秒,可根据实际情况修改sentinel failover-timeout mymaster 900000sentinel down-after-milliseconds mymaster 30000 # sentinel认为redis服务器已经断线所需的毫秒数 配置到这里,基本上sentinel服务器已经配置好了,剩下的就是依次进入26380和26381文件夹修改对应的配置,注意更换端口,不然启动时会端口冲突 配置完成之后,启动就变得很简单了,由于没有配置sentinel的后台启动,所以每个服务器都会占用一个连接,就需要多开连接进行了 12cd /redis-26379src/redis-sentinel sentinel.conf 如果你能看到这个经典的启动界面,说明你的sentinel服务器已经启动了,你离成功也就差几个命令了 在新开的连接窗口,进入sentinel服务器根目录 12cd /usr/soft/redis/redis-26380src/redis-sentinel sentinel.conf 启动成功之后,你能看到启动界面,并且能打印之前我们启动的那台sentinel服务器信息,说明这台sentinel也已经启动成功了 并且之前启动的端口号为26379的那台sentinel服务器也会打印这台服务器信息 说明两天sentinel服务器已经正常监听了6379的redis主服务器,并且两台sentinel也建立了通信 如果新开的sentinel服务器显示redis主服务器离线,并且也没有打印26379的服务器信息,说明服务器的配置处理问题重点检查是否配置了redis主服务器的验证密码,redis主服务器的IP端口是否正确 剩下的就是按照以上步骤,启动端口为26381的sentinel服务器. 12cd /usr/soft/redis/redis-26381src/redis-sentinel sentinel.conf 如果你能在之前启动的两台服务器日志里看到26381的日志打印信息,说明服务器启动成功. 这时,你的Linux下的redis读写分离和高可用的环境已经搭建完成,当有主服务器宕机之后,sentinel服务器会自动选举出新的服务器并且进行切换,宕机的服务器重新上线后会自动作为从服务器加入集群环境.]]></content>
      <categories>
        <category>Java</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下的hexo+GitHub个人博客搭建]]></title>
    <url>%2Fp%2Fae3b3943%2F</url>
    <content type="text"><![CDATA[windows下的hexo+GitHub个人博客搭建1、node.js的下载与安装1)、下载node.js去node的官方网站下载windows版本的zip文件node.js的官方下载连接 下载后解压至任意目录 在解压后目录中新建两个文件夹(用来存放npm全局模块的安装目录,也可以指定其他目录 node-cachenode-global 2)、配置环境变量新建NODE_HOME12变量名:NODE_HOME变量值:C:\Java\node-v10.15.0-win-x64(路径为解压node后存放的根目录) 配置path,最后一个为你安装hexo根目录下的node_modules/hexo/bin123%NODE_HOME%%NODE_HOME%\node-globalC:\Java\hexo\node_modules\hexo\bin 2、安装gitgit下载地址:https://www.git-scm.com/download/ 去git官网下载相对于的版本进行安装 安装成功后可以通过git –version测试是否安装成功 12C:\Users\siworae&gt;git --versiongit version 2.10.2.windows.1 3、注册GitHub账号和创建GitHub仓库在GitHub官网注册GitHub账号 1)、创建仓库 创建git仓库时候，仓库的名称有格式要求，例如我的GitHub仓库用户名是siworae,仓库名称就是siworae.github.io 然后点击下面的create repository就可以成功创建GitHub仓库了,创建完之后会跳转到一个新的界面,不要关闭.留着它 4、安装hexohexo官方中文文档:https://hexo.io/zh-cn/docs/index.html hexo中的命令介绍 1234hexo g #完整命令为hexo generate，用于生成静态文件 hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览 hexo d #完整命令为hexo deploy，用于将本地文件发布到github上 hexo n #完整命令为hexo new，用于新建一篇文章 在任意目录新建hexo文件夹(名字任意),我在C盘中新建了一个hexo文件夹,进入这个文件夹,鼠标右键选择”Git Bash here”进入git命令行窗口,执行以下命令设施node、安装hexo和git依赖 1)、设置node12npm config set prefix "C:\Java\node-v10.15.0-win-x64\node-global"npm config set cache "C:\Java\node-v10.15.0-win-x64\node-cache" 此处地址为安装目录,根据你们实际情况修改 2)、设置npm国内源1npm config set registry "https://registry.npm.taobao.org" 3)、测试node是否安装成功12node -vnpm -v 1234C:\Users\siworae&gt;node -vv10.15.0C:\Users\siworae&gt;npm -v6.4.1 出现这个则说明安装成功 4)、安装hexo文中所有路径都尽量不要包含中文路径,不然很容易出现各种稀奇古怪的错误 12npm install hexo-cli -gnpm install hexo-deployer-git --save 初始化hexo 1hexo init 安装依赖 1npm insatll 生成静态文件 1hexo g 启动本地服务,就可以进行本地预览了,启动之后这个窗口不能关闭,不然博客无法访问 1hexo s 这个时候我们就可以在浏览器输入:http://127.0.0.1:4000进行访问我们的博客了,但是此时博客还是只在我们本地上,想要在外网可以访问还需要将博客发布到GitHub上 5、部署本地网站到GitHub1)、设置GitHub和git首先,需要将你的git连接上你的GitHub 在Git Bash here命令行窗口输入GitHub中设置的用户名和关联邮箱进行本地git设置 12git config --global user.name "your name" git config --global user.email your_email@youremail.com 在本机上生成ssh的密钥用于GitHub登陆(your_email@youremail.com改为自己在GitHub绑定的邮箱) 1ssh-keygen -t rsa -C your_email@youremail.com 然后一路回车,系统会自动将生成的公钥和私钥文件保存在C:\Users\siworae.ssh文件夹里面(siworae为自己的电脑用户名) .ssh为隐藏文件夹,需要开启显示隐藏文件才能看到 在文件夹里面找到id_rsa.pub文件,用记事本或者notepad打开,复制. 打开GitHub登陆,点击settings 在SSH Keys/Add new界面中,title填写标题,可随意,key一栏填写刚刚复制的id_rsa.pub文件里面的内容.点击页面下面的Add SSH key就添加成功了 2)、配置hexo配置文件在hexo安装根目录下找到_config.yml文件. 用记事本或者notepad打开,在最后面添加GitHub的信息 注意在hexo所有的配置文件中,冒号后面都需要跟一个空格,不然会报错 repository填写你的仓库地址,在创建完仓库之后就会跳转到这个界面,选择SSH.复制路径 1234deploy: type: git repository: git@github.com:siworae/siworae.github.io.git branch: master 这个时候你的GitHub已经和hexo关联起来了 12hexo gheox d 将本地代码推送到GitHub上,然后你可以到GitHub仓库看看代码是否已经推送成功.成功之后你就可以通过siworaer.GitHub.io网址来访问自己的博客了 6、主题安装进入hexo目录.打开git命令行窗口,执行以下命令将主题文件下载至hexo/themes目录,这里我已安装BlueLake主题为例,具体主题可以到官网下载https://hexo.io/themes/ 1git clone https://github.com/chaooo/hexo-theme-BlueLake.git hexo安装根目录下找到_config.yml文件,将landscape改为BlueLake 12#theme: landscapetheme: BlueLake 清除缓存并重新生成静态文件 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 打开浏览器就可以查看新的主题效果了 具体的主题设置可以参照官方文档https://github.com/chaooo/hexo-theme-BlueLake#bluelake 7、修改站点配置信息hexo安装根目录下找到_config.yml文件 1)、设置语言 1language: zh-CN 2)、设置个人信息 12345title: ##标题subtitle: ##副标题description: ##简要描述keywords: ##关键字author: ##作者信息 然后重新推送到GitHub上,然后你的个人博客基本上就大功告成了.]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
