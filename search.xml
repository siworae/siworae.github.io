<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx负载均衡的实现]]></title>
    <url>%2Fp%2Ffffa5954%2F</url>
    <content type="text"><![CDATA[Nginx负载均衡的实现1、Nginx安装1.1 安装依赖1yum install gcc openssl-devel pcre-devel zlib-devel -y 1.2 下载与安装官方网站下载 根据自己的系统版本下载对应版本的压缩包 上传至服务器 解压缩 1tar -zxvf nginx-1.8.1.tar.gz 进入解压后的目录,设置安装的目录,/usr/soft/nginx为你要安装的路径 1./configure --prefix=/usr/soft/nginx 编译并安装 1make &amp;&amp; make install 安装完成之后就会在/usr/soft/目录下生成nginx目录,这个就是安装后的nginx了 1.3 配置nginx进入/etc/rc.d/init.d/目录,新建nginxd文件 在nginxd文件中写入以下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15 # description: Nginx is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid # Source function library.. /etc/rc.d/init.d/functions # Source networking configuration.. /etc/sysconfig/network # Check that networking is up.[ "$NETWORKING" = "no" ] &amp;&amp; exit 0 nginx="/usr/soft/nginx/sbin/nginx"prog=$(basename $nginx) NGINX_CONF_FILE="/usr/soft/nginx/conf/nginx.conf" [ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx lockfile=/var/lock/subsys/nginx make_dirs() &#123; # make required directories user=`nginx -V 2&gt;&amp;1 | grep "configure arguments:" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -` options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d "=" -f 2` if [ ! -d "$value" ]; then # echo "creating" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done&#125; start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $"Starting $prog: " daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125; stop() &#123; echo -n $"Stopping $prog: " killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125; restart() &#123; configtest || return $? stop sleep 1 start&#125; reload() &#123; configtest || return $? echo -n $"Reloading $prog: " killproc $nginx -HUP RETVAL=$? echo&#125; force_reload() &#123; restart&#125; configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125; rh_status() &#123; status $prog&#125; rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125; case "$1" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;" exit 2esac 然后修改nginxd文件的权限,使其拥有可执行权限 1chmod +x nginxd 添加进系统服务 1chkconfig --add nginxd 查看是否添加成功 1chkconfig --list nginxd 出现以下则说明添加成功 接下来就可以启动nginxd了 1service nginxd start 启动后在浏览器输入你的服务器IP+80端口就可以看到以下界面了 至此,你的nginx已经安装成功. 2、Nginx的配置nginx的负载均衡配置主要有四种: 轮询负载均衡:对应用程序服务器的请求以循环方式分发 加权负载均衡:根据对应服务器的权重进行分发 最少连接数:将下一个请求分配给活动连接数最少的服务器 ip-hash:哈希函数用于确定下一个请求（基于客户端的IP地址）应该选择哪个服务器 2.1 轮询配置 siworae:设置自定义的访问路径 server:设置业务服务器的IP 1234567891011121314http &#123; upstream siworae&#123; server srv1.example.com; server srv2.example.com; server srv3.example.com; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://siworae; &#125; &#125; &#125; 2.2 加权配置通过使用服务器权重，还可以进一步影响nginx负载均衡算法，谁的权重越大，分发到的请求就越多 1234567891011121314http &#123; upstream siworae&#123; server srv1.example.com weight=3; server srv2.example.com; server srv3.example.com; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://siworae; &#125; &#125; &#125; 2.3 最少连接配置在连接负载最少的情况下，nginx会尽量避免将过多的请求分发给繁忙的应用程序服务器，而是将新请求分发给不太繁忙的服务器，避免服务器过载 123456789101112131415http &#123; upstream siworae&#123; least_conn; server srv1.example.com; server srv2.example.com; server srv3.example.com; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://siworae; &#125; &#125; &#125; 2.4 ip-hsah使用ip-hash，客户端的IP地址将用作散列键，以确定应该为客户端的请求选择服务器组中的哪台服务器。此方法可确保来自同一客户端的请求将始终定向到同一台服务器，除非此服务器不可用. 123456789101112131415http &#123; upstream siworae&#123; ip_hash; server srv1.example.com; server srv2.example.com; server srv3.example.com; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://siworae; &#125; &#125; &#125; 上述的循环或最少连接数的负载平衡方法，每个后续客户端的请求都可能被分发到不同的服务器。不能保证相同的客户端总是定向到相同的服务器。如果需要将客户端绑定到特定的应用程序服务器，换句话说，就是始终选择相同的服务器而言，就要使客户端的会话“粘滞”或“持久” ，ip-hash负载平衡机制就是有这种特性。]]></content>
      <categories>
        <category>Java</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring集成RabbitMQ]]></title>
    <url>%2Fp%2Fee9f7bfc%2F</url>
    <content type="text"><![CDATA[Spring集成RabbitMQ1、RabbitMQMQ ,也就是消息队列是一种进程间通信或同一进程的不同线程间的通信方式,软件的贮列用来处理一系列的输入,通常是来自用户.消息队列提供了异步的通信协议,每一个贮列中的纪录包含详细说明的数据,包含发生的时间,输入设备的种类,以及特定的输入参数,也就是说,消息的发送者和接收者不需要同时与消息队列互交.消息会保存在队列中,直到接收者取回它。 目前,市面上拥有MQ的有很多,比如RabbMQ,ActiveMQ,ZeroMQ,Kafka等,今天我们使用的是RabbitMQ,至于为什么选用RabbitMQ,可以参考这篇博文:https://blog.csdn.net/linsongbin1/article/details/47781187 消息队列的使用场景在项目中,将一些无需即时返回且耗时的操作提取出来,进行了异步处理,而这种异步处理的方式大大的节省了服务器的请求响应时间,从而提高了系统的吞吐量. 2、RabbitMQ的下载与安装1)、Erlang环境准备因为RabbitMQ是依赖与Erlang的,所有需要先安装Erlang的, 1.1、Erlang下载与安装官方下载地址 根据自己的电脑系统版本下载对于版本的安装包,一直默认安装就行 2)、RabbitMQ Service下载与安装RabbitMQ官方下载 根据自己的电脑系统版本下载对于版本的安装包,全部默认安装就行 3)、测试打开命令行,进入RabbitMQ的安装目录下的sbin目录,输入rabbitmqctl.bat status 如果出现以下界面,说明是安装成功的.并且此时rabbitmq已经正常启动了 如果启动报错,可以尝试将C:\Windows目录下的.erlang.cookie文件拷贝覆盖到你的用户目录下C:\Users\userName 4)、管理界面在命令行输入rabbitmq-plugins.bat list 在输入rabbitmq-plugins.bat enable rabbitmq_management开启管理界面插件 管理界面的默认端口是15672,所以在浏览器输入127.0.0.1:15672即可进入管理界面 然后你就可以用默认的账户和密码登陆了 账号:guest 密码:guest 这里对管理界面的一些操作就不做详细阐述了 3、RabbitMQ快速入门在RabbitMQ的官网中给了六种快速入门的demo.有兴趣的可以去官网看看 这里只介绍四种队列的模式:work queues,publish/subscribe,routing,topics 1)、work queues自动回执和手动回执 在工作队列中,mq提供了两种回执方式,默认是自动回执, 其中设置不同回执方式就是在将队列加入到监听中指定 1channel.basicConsume(QUEUE_NAME,true,consumer); 第一个参数 QUEUE_NAME : 队列的名称 第二个参数 指定回执方式 : 默认true(自动回执),false(手动回执) 第三个参数 consumer : consumer的实现类 PS:在设置为手动回执之后,我们就需要在consumer执行完之后手动发送回执消息给mq服务器了 1channel.basicAck(envelope.getDeliveryTag(),false); 完整的demo代码请参考我的GitHub 2)、publish/subscribe在发布与订阅模式中,在生产者和队列中新增了一个角色,也就是交换机的概念,交换机有四种类型,也就对应后面的四种模式.其中最常用的是fanout, direct ,topic. 以下是三种模式下的示意图 fanout direct topic 在生产者发送消息至交换机中时,会一起发送一个key值给交换机,交换机就会根据这个key值去匹配队列和交换机绑定的时候设置的key,如果匹配就将消息发送给队列. 可以理解为交换机是一个保安,守护着队列对外的入口,当生产者生产出的消息想要进入队列的时候,就需要带着key,也就是门票了,然后保安就会检查这个门票,看看这个门票符合那个就放它进哪个队列,如果不符合就不让进,也就是将这个消息丢弃了. 三种模式的区别是: fanout : 不进行key校验,只要队列绑定了交换机我就将消息发送给你 direct : key值为固定值,通用性较差 topic : key值可以使用通配符模式 123.:分割字符串*:匹配一个单词 不能为空#:匹配多个单词 可为空 完整的demo代码请参考我的GitHub 4、Spring集成RabbitMQ1)、引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;1.6.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2)、模板类 12345678public class TestSpringRabbitmq &#123; public static void main(String[] args) &#123; ApplicationContext ac=new ClassPathXmlApplicationContext("spring-rabbitmq.xml"); AmqpTemplate amqpTemplate= (AmqpTemplate) ac.getBean("amqpTemplate"); //amqpTemplate.convertAndSend("hello spring rabbitmq"); amqpTemplate.convertAndSend("springExchange02","query.queryById","hello spring rabbitmq"); &#125;&#125; 3)、配置消费类 123456789public class ConsumerService &#123; public void test(Object obj)&#123; System.out.println("消息者01收到消息--&gt;"+obj); &#125; public void test02(Object obj)&#123; System.out.println("消息者02收到消息--&gt;"+obj); &#125;&#125; 4)、设置配置文件 resources资源目录新建spring-rabbitmq.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd" &gt; &lt;context:component-scan base-package="com.siworae"/&gt; &lt;!-- 配置工厂类 --&gt; &lt;rabbit:connection-factory id="connectionFactory" host="127.0.0.1" port="5672" virtual-host="/siworae"sername="siworae"password="123456"&gt;&lt;/rabbit:connection-factory&gt; &lt;rabbit:admin connection-factory="connectionFactory"&gt;&lt;/rabbit:admin&gt; &lt;!-- 配置交换机 --&gt; &lt;rabbit:topic-exchange name="springExchange"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern="spring.#" queue="spring_test"&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:topic-exchange&gt; &lt;rabbit:topic-exchange name="springExchange02"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern="query.*" queue="spring_test_02"&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:topic-exchange&gt; &lt;!-- 配置队列 --&gt; &lt;rabbit:queue name="spring_test"&gt;&lt;/rabbit:queue&gt; &lt;rabbit:queue name="spring_test_02"&gt;&lt;/rabbit:queue&gt; &lt;!-- 配置监听容器 --&gt; &lt;rabbit:listener-container connection-factory="connectionFactory"&gt; &lt;rabbit:listener ref="consumerService" method="test" queue-names="spring_test"&gt;&lt;/rabbit:listener&gt; &lt;rabbit:listener ref="consumerService" method="test02" queue-names="spring_test_02"&gt;&lt;/rabbit:listener&gt; &lt;/rabbit:listener-container&gt; &lt;!-- 配置amqpTemplate --&gt; &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="springExchange" routing-key="spring.test"&gt;&lt;/rabbit:template&gt;&lt;/beans&gt; 完整demo可以cloneGitHub]]></content>
      <categories>
        <category>Spring</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Netty的websocket简单实现]]></title>
    <url>%2Fp%2F64c322b1%2F</url>
    <content type="text"><![CDATA[基于Netty的websocket简单实现参考文献:Netty 4.x 用户指南 netty是个啥?其实netty就是一个将JDK原生的NIO封装好的一个框架,可以让你不需要关注JDK原生NIO的各种概念便可以开发出一个网络应用. 官方点的说法就是Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 Netty的优势 使用JDK自带的NIO需要了解太多的概念，编程复杂，一不小心bug横飞 Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型 Netty自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑 Netty解决了JDK的很多包括空轮询在内的bug Netty底层对线程，selector做了很多细小的优化，精心设计的reactor线程模型做到非常高效的并发处理 定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展 Netty社区活跃，遇到问题随时邮件列表或者issue Netty已经历各大rpc框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大 下面就是一个利用Netty来实现的网络聊天室 DEMO引入依赖12345678910111213141516&lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --&gt;&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.30.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 客户端处理类,用于处理合HTTP请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 客户端处理类 * 扩展 SimpleChannelInboundHandler 用于处理 FullHttpRequest信息 */public class HttpRequestHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; &#123; private final String wsUri; private static final File INDEX; static &#123; URL location = HttpRequestHandler.class.getProtectionDomain().getCodeSource().getLocation(); try &#123; String path = location.toURI() + "WebsocketChatClient.html"; path = !path.contains("file:") ? path : path.substring(5); INDEX = new File(path); &#125; catch (URISyntaxException e) &#123; throw new IllegalStateException("Unable to locate WebsocketChatClient.html", e); &#125; &#125; public HttpRequestHandler(String wsUri) &#123; this.wsUri = wsUri; &#125; @Override public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception &#123; //如果请求是WebSocket升级,递增引用计数器(保留)并且将它传递给在ChannelPipeline中的下个ChannelInboundHandler if (wsUri.equalsIgnoreCase(request.getUri())) &#123; ctx.fireChannelRead(request.retain()); &#125; else &#123; //处理符合 HTTP 1.1的 “100 Continue” 请求 if (HttpHeaders.is100ContinueExpected(request)) &#123; send100Continue(ctx); &#125; //读取默认的 WebsocketChatClient.html 页面 RandomAccessFile file = new RandomAccessFile(INDEX, "r"); HttpResponse response = new DefaultHttpResponse(request.getProtocolVersion(), HttpResponseStatus.OK); response.headers().set(HttpHeaders.Names.CONTENT_TYPE, "text/html; charset=UTF-8"); boolean keepAlive = HttpHeaders.isKeepAlive(request); //判断keepalive是否在请求头里面 if (keepAlive) &#123; response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, file.length()); response.headers().set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.KEEP_ALIVE); &#125; //写HttpResponse到客户端 ctx.write(response); //写index.html到客户端,判断SslHandler是否在ChannelPipeline来决定是使用DefaultFileRegion还是ChunkedNioFile if (ctx.pipeline().get(SslHandler.class) == null) &#123; ctx.write(new DefaultFileRegion(file.getChannel(), 0, file.length())); &#125; else &#123; ctx.write(new ChunkedNioFile(file.getChannel())); &#125; //写并刷新LastHttpContent到客户端，标记响应完成 ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT); //如果keepalive没有要求，当写完成时，关闭Channel if (!keepAlive) &#123; future.addListener(ChannelFutureListener.CLOSE); &#125; file.close(); &#125; &#125; private static void send100Continue(ChannelHandlerContext ctx) &#123; FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE); ctx.writeAndFlush(response); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; Channel incoming = ctx.channel(); System.out.println("Client:"+incoming.remoteAddress()+"异常"); // 当出现异常就关闭连接 cause.printStackTrace(); ctx.close(); &#125;&#125; 处理 WebSocket frame123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * TextWebSocketFrameHandler 继承自 SimpleChannelInboundHandler，这个类实现了 ChannelInboundHandler 接口， * ChannelInboundHandler 提供了许多事件处理的接口方法，然后你可以覆盖这些方法。 * 现在仅仅只需要继承 SimpleChannelInboundHandler 类而不是你自己去实现接口方法。 */public class TextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123; public static ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE); /** * 每当从服务端读到客户端写入信息时，将信息转发给其他客户端的 Channel。 * 其中如果你使用的是 Netty 5.x 版本时，需要把 channelRead0() 重命名为messageReceived() * @param ctx * @param msg * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext ctx,TextWebSocketFrame msg) throws Exception &#123; Channel incoming = ctx.channel(); for (Channel channel : channels) &#123; if (channel != incoming)&#123; channel.writeAndFlush(new TextWebSocketFrame("[" + incoming.remoteAddress() + "]" + msg.text())); &#125; else &#123; channel.writeAndFlush(new TextWebSocketFrame("[you]" + msg.text() )); &#125; &#125; &#125; /** * 每当从服务端收到新的客户端连接时，客户端的 Channel 存入 ChannelGroup 列表中，并通知列表中的其他客户端 Channel * @param ctx * @throws Exception */ @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; Channel incoming = ctx.channel(); // Broadcast a message to multiple Channels channels.writeAndFlush(new TextWebSocketFrame("[SERVER] - " + incoming.remoteAddress() + " 加入")); channels.add(incoming); System.out.println("Client:"+incoming.remoteAddress() +"加入"); &#125; /** * 每当从服务端收到客户端断开时，客户端的 Channel 自动从 ChannelGroup 列表中移除了，并通知列表中的其他客户端 Channel * @param ctx * @throws Exception */ @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123; // (3) Channel incoming = ctx.channel(); // Broadcast a message to multiple Channels channels.writeAndFlush(new TextWebSocketFrame("[SERVER] - " + incoming.remoteAddress() + " 离开")); System.out.println("Client:"+incoming.remoteAddress() +"离开"); // A closed Channel is automatically removed from ChannelGroup, // so there is no need to do "channels.remove(ctx.channel());" &#125; /** * 服务端监听到客户端活动 * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // (5) Channel incoming = ctx.channel(); System.out.println("Client:"+incoming.remoteAddress()+"在线"); &#125; /** * 服务端监听到客户端不活动 * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; // (6) Channel incoming = ctx.channel(); System.out.println("Client:"+incoming.remoteAddress()+"掉线"); &#125; /** * 当出现 Throwable 对象才会被调用，即当 Netty 由于 IO 错误或者处理器在处理事件时抛出的异常时。 * 在大部分情况下，捕获的异常应该被记录下来并且把关联的 channel 给关闭掉。 * 然而这个方法的处理方式会在遇到不同异常的情况下有不同的实现，比如你可能想在关闭连接之前发送一个错误码的响应消息。 * @param ctx * @param cause * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) // (7) throws Exception &#123; Channel incoming = ctx.channel(); System.out.println("Client:"+incoming.remoteAddress()+"异常"); // 当出现异常就关闭连接 cause.printStackTrace(); ctx.close(); &#125;&#125; 初始化ChannelPipeline给channel12345678910111213141516public class WebsocketChatServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new HttpServerCodec()); pipeline.addLast(new HttpObjectAggregator(64*1024)); pipeline.addLast(new ChunkedWriteHandler()); pipeline.addLast(new HttpRequestHandler("/ws")); pipeline.addLast(new WebSocketServerProtocolHandler("/ws")); pipeline.addLast(new TextWebSocketFrameHandler()); &#125;&#125; 编写主方法启动服务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class WebsocketChatServer &#123; private int port; public WebsocketChatServer(int port) &#123; this.port = port; &#125; public void run() throws Exception &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new WebsocketChatServerInitializer()) .option(ChannelOption.SO_BACKLOG, 128) .childOption(ChannelOption.SO_KEEPALIVE, true); System.out.println("WebsocketChatServer 启动了"); // 绑定端口，开始接收进来的连接 ChannelFuture f = b.bind(port).sync(); // 等待服务器 socket 关闭 。 // 在这个例子中，这不会发生，但你可以优雅地关闭你的服务器。 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); System.out.println("WebsocketChatServer 关闭了"); &#125; &#125; public static void main(String[] args) throws Exception &#123; int port; if (args.length &gt; 0) &#123; port = Integer.parseInt(args[0]); &#125; else &#123; port = 8080; &#125; new WebsocketChatServer(port).run(); &#125;&#125; 客户端在程序的resources目录下新建WebsocketChatClient.html 页面来作为客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;WebSocket Chat&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; var socket; if (!window.WebSocket) &#123; window.WebSocket = window.MozWebSocket; &#125; if (window.WebSocket) &#123; socket = new WebSocket("ws://127.0.0.1:8080/ws"); socket.onmessage = function(event) &#123; var ta = document.getElementById('responseText'); ta.value = ta.value + '\n' + event.data &#125;; socket.onopen = function(event) &#123; var ta = document.getElementById('responseText'); ta.value = "连接开启!"; &#125;; socket.onclose = function(event) &#123; var ta = document.getElementById('responseText'); ta.value = ta.value + "连接被关闭"; &#125;; &#125; else &#123; alert("你的浏览器不支持 WebSocket！"); &#125; function send(message) &#123; if (!window.WebSocket) &#123; return; &#125; if (socket.readyState == WebSocket.OPEN) &#123; socket.send(message); &#125; else &#123; alert("连接没有开启."); &#125; &#125;&lt;/script&gt;&lt;form onsubmit="return false;"&gt; &lt;h3&gt;WebSocket 聊天室：&lt;/h3&gt; &lt;textarea id="responseText" style="width: 500px; height: 300px;"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;input type="text" name="message" style="width: 300px" value="hehe"&gt; &lt;input type="button" value="发送消息" onclick="send(this.form.message.value)"&gt; &lt;input type="button" onclick="javascript:document.getElementById('responseText').value=''" value="清空聊天记录"&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 先运行 WebsocketChatServer，再打开多个浏览器页面实现多个客户端访问 http://localhost:8080 那么,你就可以看到一个基于Netty实现的一个简单的网络应用了.]]></content>
      <categories>
        <category>Java</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket实现Java后台消息推送]]></title>
    <url>%2Fp%2F1e2cf77e%2F</url>
    <content type="text"><![CDATA[WebSocket实现Java后台消息推送1、WebSocket是什么WebSocket是一种在单个TCP连接上进行全双工通信的协议,WebSocket协议的出现使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据. 2、WebSocket与其他方式（Ajax轮询和long poll）之前大多数的后台消息推送都是使用ajax轮询实现的,也就是利用异步js和Ajax在一定的时间间隔向服务器发起HTTP请求,将服务器的信息主动的拉取过来,但是这种方式本质上还是HTTP,不断的发起请求,断开请求,效率低下,而且非常消耗资源. long poll其实和Ajax轮询差不多,也是浏览器发起请求,但是连接不断开,一直保存着,直到服务器有新的消息了,才带着新信息响应给浏览器, 以上这两种方式,对服务器都有一定的要求,都是不断的在建立HTTP连接,然后等待服务器处理请求 简单来说,这两种方式就相当于,服务器不会主动的联系(发起请求)浏览器,但是boss有命令,不管你多累,你都得接待好这些客人(请求). Ajax轮询要求服务器有很快的处理速度,而long poll则要求服务器要有很高的并发了. 而WebSocket在建立连接之后,这种连接状态会一直保持,而且服务器也可以主动给浏览器发送消息,而不是被动的等待浏览器请求了之后才能给浏览器发送消息. Ajax轮询的连接示意图 long poll连接示意图 WebSocket连接示意图 只需要经过一次HTTP请求，就可以做到源源不断的信息传送了.(在程序设计中,这种设计叫做回调,即:你有信息了再来通知我,而不是我傻乎乎的每次跑来问你 ) websocket协议解决了之前协议的同步有延迟,并且非常消耗资源的情况,但是这样看来是不是觉得websocket也一样是连接一直建立着啊,不和long poll一样么?为什么它就能减少服务器资源的消耗呢? 这里就要探讨一下程序的访问过程了 我们经常进行的访问实际上是要经过两成代理的,浏览器发起HTTP请求,在经过Nginx等服务器的解析下,在发送给对应的handler处理请求.有点类似于我们打客服电话,打进去之后有一个智能系统(Nginx)根据不同的业务转接给不同的客服(handler)处理. 智能系统的处理速度是很快的,但是我们每次打客服电话的时候是卡在哪里呢?等客服接听对不对,这就相应地智能系统是能够满足需求的,但是由于客服的处理速度太慢,导致客服数量不足,满足不了接待需求. 这就相当于传统的Ajax轮询和long poll方式,而websocket就解决了这个问题. 我们打客服电话的时候,我们一直和智能系统保存着连接,不挂电话,当客服处理好了问题或者有消息的时候,客服只要通知智能系统就可以,而智能系统统一的通知我们,这样就能解决客服处理过慢的问题了 而且,websocket比传统方式还有一个优势,因为HTTP协议是无状态的,当你断开连接后服务器就不认识你是谁了,你每次连接都需要重新发送一个鉴别信息给服务器,然后服务器解析这个信息来知道你是谁, 虽然智能系统的处理速度很快,但是你每次接通电话之后都需要balabal的说一大堆和按键跳转来告诉系统你是谁和要处理什么业务,然后系统不断的把这些信息转交给客服,这样不但浪费智能系统和客服的处理时间,在转交的过程中也会占用时间. 而websocket不一样,只需要第一次连接的时候需要发送鉴别信息,之后连接状态一直保持着,这样就避免了HTTP协议的无状态性. 这样就解决了你需要不断的告诉系统你是谁,你要干什么.直到你挂断电话之前,系统都能知道你是谁,要干什么. 而且处理方式也从需要我们不断的问客服处理的怎么样了转变成客服有消息了就会通知我们,没有消息的时候这个通话连接就交给智能系统处理,避免了占用客服. ３、WebSocket与HTTPWebsocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手. WebSocket也是HTTP5定义的一个协议,它和HTTP协议有关系,但是和HTTP协议本身没有关系,WebSocket是独立并且依赖于HTTP协议. WebSocket与HTTP到底有什么区别和联系呢? 在HTTP协议中,1.0版本中最明显的特点就是无状态无连接,而在1.1的版本中新增了所谓的 keep-alive,也就是把多个HTTP请求合并为一个,但是WebSocker是一个新的协议,只是利用了HTTP完成了握手而已. webSocker和HTTP有交集,但不是全部. 下面我们对比一下WebSocket和HTTP的请求头信息 这个是基于WebSocket的客户端请求(此处感谢wikipedia) 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 这个是基于WebSocket的服务器响应 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat HTTP的请求头 12345678GET /item/WebSocket HTTP/1.1Host: baike.baidu.comConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8 HTTP的响应头 1234HTTP/1.1 200 OKContent-Language: zh-CNContent-Type: text/html; charset=utf-8Server: Jetty(6.1.25) 在WebSocket请求中比HTTP请求中多了几个东西 12Upgrade: websocketConnection: Upgrade 这个就是WebSocket中主要也是核心的东西,告诉服务器发起的是WebSocket请求,而不是HTTP请求. 123Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 Sec-WebSocket-Key : 是一个base64 encode的值,这个值是浏览器随机生成的,用来验证服务器是否切换至WebSocket协议 Sec-WebSocket-Protocol : 这个是用户自定义的一个字符串,用来定义同一个URL下不同的服务使用不同的协议. Sec-WebSocket-Version : 这个是告诉服务器当前协议的版本. 服务器接收到请求之后返回的响应头也多了些东西,此时连接已经建立了. 1234Upgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat Upgrade和Connection : 告诉浏览器,我已经切换到websocket协议了 Sec-WebSocket-Accept : 这个是服务器确认并且加密过的Sec-WebSocket-Key,告诉浏览器我用的真的是webSocket协议,不是骗你的哈! Sec-WebSocket-Protocol : 告诉浏览器最终使用的协议版本 当服务器返回响应后,HTTP的工作已经全部结束了,浏览器和服务器就可以抛弃HTTP，开始使用WebSocket协议来工作了 4、demo1)、创建maven工程项目目录一览 2)、项目添加依赖主要是在spring项目中新增websocket依赖,下面贴出完整的xml配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.justsoul.study&lt;/groupId&gt; &lt;artifactId&gt;websocket_demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;4.3.10.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志打印相关的jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;websocket&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/ws&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3)、配置xmlspring.xml 12&lt;context:annotation-config/&gt;&lt;context:component-scan base-package="com.siworae.websocket"/&gt; spring_mvc.xml 1234567&lt;context:component-scan base-package="com.siworae.websocket" /&gt;&lt;mvc:annotation-driven/&gt;&lt;mvc:resources mapping="/js/**" location="/js/"/&gt;&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; web.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring_mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4)、创建websocket拦截器新建一个MyHandshakeInterceptor类,并继承HttpSessionHandshakeInterceptor. 拦截器主要处理的是在握手建立连接前后需要处理的事情,这个demo只是简单的在控制台输出了一句话. 在握手建立连接前做了一个处理,用来区分WebSocketHandler 1234567891011121314151617181920212223public class MyHandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123; @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; System.out.println("beforeHandshake"); if (request instanceof ServletServerHttpRequest) &#123; ServletServerHttpRequest servletRequest = (ServletServerHttpRequest) request; HttpSession session = servletRequest.getServletRequest().getSession(false); if (session != null) &#123; //使用userName区分WebSocketHandler，以便定向发送消息 String userName = (String) session.getAttribute("SESSION_USERNAME"); if (userName == null) &#123; userName = "system-" + session.getId(); &#125; attributes.put("WEBSOCKET_USERNAME", userName); &#125; &#125; return true; &#125; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123; System.out.println("afterHandshake"); &#125;&#125; 5)、创建websocket处理器在有了拦截器之后,就需要有处理器来处理建立连接之后的事了. websocket处理器继承了TextWebSocketHandler类,当然你也可以继承AbstractWebSocketHandler TextWebSocketHandler继承自AbstractWebSocketHandler类用来处理文本消息。BinaryWebSocketHandler继承自AbstractWebSocketHandler类用来处理二进制消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class MyWebSocketHandler extends TextWebSocketHandler &#123; //已建立连接的用户 private static final ArrayList&lt;WebSocketSession&gt; users = new ArrayList&lt;WebSocketSession&gt;(); /** * 当新连接建立的时候，被调用 * 连接成功时候，会触发页面上onOpen方法 * @param session * @throws Exception */ @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; System.out.println("afterConnectionEstablished"); users.add(session); System.out.println("zxrs:----&gt;"+users.size()); super.afterConnectionEstablished(session); &#125; /** * 处理前端发送的文本信息 * js调用websocket.send时候，会调用该方法 * @param session * @param message * @throws Exception */ @Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123; String username = (String) session.getAttributes().get("WEBSOCKET_USERNAME"); // 获取提交过来的消息详情 System.out.println("收到用户 " + username + "的消息:" + message.toString()); //回复一条信息， session.sendMessage(new TextMessage("reply msg:" + message.getPayload())); &#125; /** * 当连接关闭时被调用 * @param session * @param status * @throws Exception */ @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123; System.out.println("afterConnectionClosed"); users.remove(session); System.out.println("zxrs:----&gt;"+users.size()); super.afterConnectionClosed(session, status); &#125; /** * 给所有在线用户发送消息 * 自定义方法 * @param message */ public void sendMessageToUsers(TextMessage message) &#123; System.out.println(users.toString()); for (WebSocketSession user : users) &#123; try &#123; if (user.isOpen()) &#123; user.sendMessage(message); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 给某个用户发送消息 * 自定义方法 * @param userName * @param message */ public void sendMessageToUser(String userName, TextMessage message) &#123; for (WebSocketSession user : users) &#123; if (user.getAttributes().get("WEBSOCKET_USERNAME").equals(userName)) &#123; try &#123; if (user.isOpen()) &#123; user.sendMessage(message); &#125;else &#123; System.out.println("------------&gt;连接关闭了!"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; break; &#125; &#125; &#125;&#125; 6)、创建websocket配置类我们使用它来加载咱们的拦截器和处理器,使能建立websocket连接. 这里使用了一种备用方案,就额是sockjs,这个是可以在不支持websocket的浏览器中只用这个协议来连接 SockJS是WebSocket 技术的一种模拟.SockJS会尽可能对应WebSocket API,但如果WebSocket技术不可用的话,就会选择另外的通信方式协议. 1234567891011121314@Configuration@EnableWebSocketpublic class WebSocketConfig extends WebMvcConfigurerAdapter implements WebSocketConfigurer &#123; public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; String websocket_url = "/websocket/socketServer.do"; registry.addHandler(new MyWebSocketHandler(), websocket_url).addInterceptors(new MyHandshakeInterceptor()); String sockjs_url = "/sockjs/socketServer.do"; registry.addHandler(new MyWebSocketHandler(), sockjs_url).addInterceptors(new MyHandshakeInterceptor()).withSockJS(); &#125;&#125; 7)、创建controller 123456789101112131415161718192021222324252627282930313233343536373839404142@Controllerpublic class WebSocketController &#123; @Bean//这个注解会从Spring容器拿出Bean public MyWebSocketHandler infoHandler() &#123; return new MyWebSocketHandler(); &#125; @RequestMapping(value = "/index", method = RequestMethod.GET) public ModelAndView goIndex()&#123; ModelAndView mv = new ModelAndView(); mv.setViewName("index"); return mv; &#125; @RequestMapping(value = "/login1", method = RequestMethod.GET) public ModelAndView index()&#123; ModelAndView mv = new ModelAndView(); mv.setViewName("login"); return mv; &#125; @RequestMapping("/login") public ModelAndView login(HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println(username + "dl"); HttpSession session = request.getSession(); session.setAttribute("SESSION_USERNAME", username); ModelAndView mv = new ModelAndView(); mv.setViewName("websocket"); return mv; &#125; @RequestMapping("/send") @ResponseBody public String send(HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println("----&gt;"+username); infoHandler().sendMessageToUser(username, new TextMessage("你好，欢迎测试！！！！")); return null; &#125;&#125; 7)、创建前台测试页面 index.jsp 用来简单的测试websocket连接和sockjs连接 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Websocket Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Websocket Demo &lt;hr&gt; &lt;button id="ws"&gt;使用ws创建连接&lt;/button&gt; &lt;button id="sockjs"&gt;使用sockjs创建连接&lt;/button&gt; &lt;button id="close"&gt;关闭websocket连接&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type="text/javascript" src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/sockjs-1.1.0.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("#ws").click(function () &#123; ws_connect(); &#125;); $("#sockjs").click(function () &#123; sockjs_connect(); &#125;); $("#close").click(function () &#123; websocket.close(); &#125;); &#125;); function ws_connect() &#123; websocket = new WebSocket("ws://localhost:8080/ws/websocket/socketServer.do"); &#125; function sockjs_connect() &#123; websocket = new SockJS("http://localhost:8080/ws/sockjs/socketServer.do"); &#125;&lt;/script&gt; login.jsp 用来实现登陆 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;Wellcome&lt;/h2&gt;&lt;body&gt;&lt;form action="login"&gt; 登录名：&lt;input type="text" name="username"/&gt; &lt;input type="submit" value="登录"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; websocket.jsp 登陆后跳转此页面,进行前后台的文本消息发送 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;Java API for WebSocket (JSR-356)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="http://cdn.bootcss.com/jquery/3.1.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.bootcss.com/sockjs-client/1.1.1/sockjs.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var websocket = null; if ('WebSocket' in window) &#123; //Websocket的连接 websocket = new WebSocket("ws://localhost:8080/ws/websocket/socketServer.do");//WebSocket对应的地址 &#125; else if ('MozWebSocket' in window) &#123; //Websocket的连接 websocket = new MozWebSocket("ws://localhost:8080/ws/websocket/socketServer.do");//SockJS对应的地址 &#125; else &#123; //SockJS的连接 websocket = new SockJS("http://localhost:8080/ws/sockjs/socketServer.do"); //SockJS对应的地址 &#125; websocket.onopen = onOpen; websocket.onmessage = onMessage; websocket.onerror = onError; websocket.onclose = onClose; function onOpen(openEvt) &#123; //alert(openEvt.Data); &#125; function onMessage(evt) &#123; alert(evt.data); &#125; function onError() &#123; &#125; function onClose() &#123; &#125; function doSend() &#123; if (websocket.readyState == websocket.OPEN) &#123; var msg = document.getElementById("inputMsg").value; websocket.send(msg);//调用后台handleTextMessage方法 alert("发送成功!"); &#125; else &#123; alert("连接失败!"); &#125; &#125; window.close = function () &#123; websocket.onclose(); &#125;&lt;/script&gt;请输入：&lt;textarea rows="3" cols="100" id="inputMsg" name="inputMsg"&gt;&lt;/textarea&gt;&lt;button onclick="doSend();"&gt;发送&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 到此,spring框架实现websocket的消息推送已经实现了. websocket请求地址一定要结合你自己的环境配置正确设置.不然可能会出现404 完整的项目代码可以去我的GitHub上下载siworae]]></content>
      <categories>
        <category>Java</category>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于zookeeper的Dubbo框架搭建]]></title>
    <url>%2Fp%2F1d70d5b2%2F</url>
    <content type="text"><![CDATA[基于zookeeper的Dubbo框架搭建工具:idea 环境:jdk1.8 本文采用了Dubbo、zookeeper及spring框架整合,实现了单机zookeeper的远程方法调用 1、Dubbo的基本介绍Dubbo官方网站:http://dubbo.apache.org Dubbo是阿里巴巴在2011年开源出来基于Java的分布式远程调用框架, dubbo是基于定义服务的概念,指定可以通过参数和返回类型远程调用的方法。在服务器端,服务器实现这个接口,并运行一个dubbo服务器来处理客户端调用。在客户端,客户机有一个存根,它提供与服务器相同的方法。 简单来说,dubbo就是: 一款分布式服务框架 高性能和透明化的RPC远程服务调用方案 SOA服务治理方案 Dubbo为我们提供了三个核心功能: 基于接口的远程调用 容错和负载均衡 服务的自动注册和发现 2、Dubbo的结构 Provider: 暴露服务的服务提供方。Consumer: 调用远程服务的服务消费方。Registry: 服务注册与发现的注册中心。Monitor: 统计服务的调用次数和调用时间的监控中心。 调用流程0.服务容器负责启动，加载，运行服务提供者。1.服务提供者在启动时，向注册中心注册自己提供的服务。2.服务消费者在启动时，向注册中心订阅自己所需的服务。3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 3、Dubbo的支持的注册中心1)、Multicast注册中心Multicast 注册中心不需要启动任何中心节点，只要广播地址一样，就可以互相发现.但这种注册方式受网络结构限制,只适合小规模应用或开发阶段使用。 使用Multicast注册中心可使用的组播地址段: 224.0.0.0 - 239.255.255.255 2、zookeeper注册中心Zookeeper是Apacahe Hadoop的子项目,是一个树型的目录服务 3、Redis注册中心是一套基于redis实现的注册中心 4、Simple注册中心Simple注册中心本身就是一个普通的 Dubbo 服务,可以减少第三方依赖.使整体通讯方式一致。 在这里我们采用的是第二种也就是zookeeper注册中心 具体的注册中心介绍可以参照官网文档http://dubbo.apache.org/zh-cn/docs/user/quick-start.html 4、Dubbo的优缺点优点: 透明化的远程方法调用 像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入 软负载均衡及容错机制 可在内网替代nginx lvs等硬件负载均衡器 服务注册中心自动注册和自动发现 不需要写死服务提供者地址，注册中心基于接口名自动查询提供者IP 服务接口监控与治理 Dubbo-admin与Dubbo-monitor提供了完善的服务接口管理与监控功能,针对不同应用的不同接口,可以进行多版本,多协议,多注册中心管理 但是缺点也很明显,就是只支持Java语言 4、zookeeper注册中心1)、zookeeper结构 Root:为zookeeper的根节点 Service:注册的服务存储节点 Type:消费方和提供方的储存节点 URL:具体的url地址 流程说明： 服务提供者启动时:向/dubbo/com.foo.BarService/providers目录下写入自己的URL地址 服务消费者启动时:订阅/dubbo/com.foo.BarService/providers目录下的提供者URL地址,并向/dubbo/com.foo.BarService/consumers目录下写入自己的URL地址 监控中心启动时:订阅/dubbo/com.foo.BarService目录下的所有提供者和消费者URL地址 2)、zookeeper客户端Dubbo支持zkclient和curator两种Zookeeper客户端实现 zkclient客户端从2.2.0版本开始缺省为zkclient实现,以提升zookeeper客户端的健状性。zkclient 是 Datameer 开源的一个 Zookeeper 客户端实现. 具体配置见后面的demo curator客户端从2.3.0版本开始支持可选curator实现.Curator是Netflix开源的一个Zookeeper客户端实现 因为这里使用的是zkclient客户端,所以对于curator客户端就不做阐述了 5、zookeeper安装本文的服务器系统使用的是centOS6.7.Windows系统下的安装步骤一样,只是启动脚本改为.cmd后缀的 1)、下载与解压zookeeper官方地址http://zookeeper.apache.org/ 12wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.11/zookeeper-3.4.13.tar.gztar -zxvf zookeeper-3.4.13.tar.gz 解压完成之后会在下载的目录下多出一个zookeeper-3.4.13.tar.gz目录,cd进入这个目录 2)、zookeeper配置在任意目录创建两个文件用来存放zookeeper的数据和日志文件夹 12mkdir /usr/soft/zookeeper/datamkdir /usr/soft/zookeeper/log cd进入conf目录,拷贝zoo_sample.cfg文件为zoo.cfg.因为zookeeper启动默认加载zoo.cfg配置文件 123cd confcp cp zoo_sample.cfg zoo.cfgvim zoo.cfg 修改配置 123dataDir=/usr/soft/zookeeper/data # 数据保存路径,填写的是你之前创建的路径dataLogDir=/usr/soft/zookeeper/log # 新增日志保存路径,填写的是你之前创建的路径clientPort=2181 # 端口号,因为这里不是集群环境,所以保持默认就好 保存退出后进入到bin目录,启动zookeeper 3)、启动zookeeper12cd bin./zkServer.sh start 看到这个提示信息说明你的zookeeper启动成功了 你可以使用客户端连接zookeeper查看 1./zkCli.sh 如果连接中出现这个,直接回车就好了 连接成功之后可以输入ls /查看 出现这个说明你的zookeeper已经启动成功了 因为是在虚拟机中测试,所有想要在本机中连接上zookeeper,最简单的办法就是将虚拟机的防火墙关掉,不然会连接超时 1service iptables stop 6、Java Demo系统要求:jdk1.6以上,maven3.0以上 1)、创建maven项目项目结构: dubbo_api:服务接口 dubbo_consumer:服务消费方 dubbo_provider:服务提供方 2)、导入依赖a.在父模块中引入依赖,因为是提供方和消费方都需要的依赖,避免重复导入,所以在父模块中引入重复的依赖 12345678910111213141516171819202122232425&lt;!-- 单元测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- dubbo --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- zookeeper客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; b.服务消费方和服务提供方都需要引入dubbo_api的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.siworae&lt;/groupId&gt; &lt;artifactId&gt;dubbo_api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 3)、接口定义实现 123public interface IUserService &#123; public Integer queryUserByUserId(Integer userId);&#125; 4)、provider服务提供方实现 123456789@Servicepublic class UserServiceImpl implements IUserService &#123; @Override public Integer queryUserByUserId(Integer userId) &#123; System.out.println("收到请求,查询参数是:"+userId); return 1; &#125;&#125; 定义一个测试类,用来发布服务 1234567public class publish &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring-provider.xml"); context.start(); System.in.read(); &#125;&#125; 5)、consumer服务实现 12 6)、xml配置a.consumer消费方配置 在main下新建资源文件夹resources,新建文件spring_consumer.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!--启动包扫描--&gt; &lt;context:component-scan base-package="com.siworae"/&gt; &lt;!--应用名称--&gt; &lt;dubbo:application name="dubbo-consumer"/&gt; &lt;!--注册中心 设置为你们自己的zookeeper服务器的IP和端口--&gt; &lt;dubbo:registry address="zookeeper://192.168.230.220:2181"/&gt; &lt;!--配置订阅服务--&gt; &lt;dubbo:reference id="userService" interface="com.siworae.service.IUserService"/&gt;&lt;/beans&gt; b.provider提供方配置 在main下新建资源文件夹resources,新建文件spring_provider.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 配置包扫描 --&gt; &lt;context:component-scan base-package="com.siworae"/&gt; &lt;!-- 服务配置 注册中心 服务列表 应用名称 --&gt; &lt;!--应用名称--&gt; &lt;dubbo:application name="dubbo_provider"/&gt; &lt;!--注册中心--&gt; &lt;!--&lt;dubbo:registry address="multicast://224.5.6.7:1234"/&gt;--&gt; &lt;!--&lt;dubbo:registry address="zookeeper://127.0.0.1:2181"/&gt;--&gt; &lt;dubbo:registry address="zookeeper://192.168.230.220:2181"/&gt; &lt;!--框架协议--&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!--配置注册的服务--&gt; &lt;dubbo:service interface="com.siworae.service.IUserService" ref="userServiceImpl"/&gt;&lt;/beans&gt; 同时在provider和consumer的资源文件夹中添加log4j配置文件,不然运行会报异常 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 7)、测试在consumer新建测试类,测试是否可以调用成功,如果控制台成功打印数字”1”.则说明调用成功 12345678public class UserControllerTest &#123; public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext("spring-consumer.xml"); UserController userController = (UserController) context.getBean("userController"); Integer user = userController.queryUserByUserId(1); System.out.println(user); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在java环境中操作redis服务器]]></title>
    <url>%2Fp%2Fb5f3cf78%2F</url>
    <content type="text"><![CDATA[在java环境中操作redis服务器工具:idea 环境:jdk1.8 1、环境配置在ieda中新建maven工程,导入依赖 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 单元测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- spring测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.8.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- log4j日志打印 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt; 2、配置文件在main下面新建资源文件夹resources.在resources下新建spring配置文件spring.xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="1024"/&gt; &lt;!-- 最大 空闲连接数 --&gt; &lt;property name="maxIdle" value="200"/&gt; &lt;!-- 获取连接时最大等待毫秒数 --&gt; &lt;property name="maxWaitMillis" value="10000"/&gt; &lt;!-- 在获取连接时检查有效性 --&gt; &lt;property name="testOnBorrow" value="true"/&gt; &lt;/bean&gt; &lt;!-- 设置redis的连接 --&gt; &lt;bean id="redisSentinelConfiguration" class="org.springframework.data.redis.connection.RedisSentinelConfiguration"&gt; &lt;property name="master"&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;property name="name" value="mymaster"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 设置sentinel --&gt; &lt;property name="sentinels"&gt; &lt;set&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;!--value改为你们自己的sentinel服务器的IP和端口 --&gt; &lt;constructor-arg name="host" value="192.168.230.221"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="26379"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg name="host" value="192.168.230.221"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="26380"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg name="host" value="192.168.230.221"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="26381"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 客户端连接工厂 --&gt; &lt;bean id="jedisConnFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;!-- 连接池引用 --&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig"/&gt; &lt;constructor-arg name="sentinelConfig" ref="redisSentinelConfiguration"/&gt; &lt;!-- value改为你们自己redis服务器的访问密码 --&gt; &lt;property name="password" value="123456"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- redis模板类配置 --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" p:connection-factory-ref="jedisConnFactory"&gt; &lt;!-- 配置序列化操作,指定key值和hashkey的序列化方式 --&gt; &lt;property name="keySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;property name="hashKeySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在resources下新建log4j配置文件log4j.properties 这个配置文件基本通用,可以不用改,直接拷过去就能用了 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 3、启动项目然后我们借助spring的测试环境测试 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;"classpath:spring.xml"&#125;)public class TestSpringDataRedis &#123; @Resource(name = "redisTemplate") private ValueOperations&lt;String,Object&gt; valueOperations; @Test public void test()&#123;// valueOperations.set("a","123"); System.out.println(valueOperations.get("a")); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下redis的读写分离配置和高可用环境配置]]></title>
    <url>%2Fp%2F9227d01%2F</url>
    <content type="text"><![CDATA[Linux下redis的读写分离配置和高可用环境配置因为高可用和主备切换需要多台服务器,准备不了那么多服务器所以本文中的多台服务器是利用一台服务器的多端口模拟多台服务器实现的 redis 服务器三台 123192.168.230.221 6379(master-主服务器)192.168.230.221 6380(slave-从服务器)192.168.230.221 6381(slave-从服务器) Sentinel 哨兵服务器三台 123192.168.230.221 26379192.168.230.221 26380192.168.230.221 26381 1、redis的安装redis官方网站:http://www.redis.cn 1)、下载并解压redis进入到指定目录,这里我下载到/usr/soft/redis目录 123cd /usr/soft/rediswget http://download.redis.io/releases/redis-5.0.3.tar.gztar zxf redis-5.0.3.tar.gz 解压之后redis目录下就会出现redis-5.0.3文件夹,cd进入这个文件夹, 因为redis是用C语言写的,所以在运行前需要对源码文件进行编译才能运行 如果你的系统里面已经有了GCC的编译环境,那么你可以直接编译,没有的话就需要安装GCC的编译环境进行对redis的源码进行编译, 1yum install gcc 安装成功之后就可以进行编译了,一定要在redis的根目录进行编译 1make 如果在编译过程中出现了command not found错误,则是没有安装GCC编译环境,重新安装完编译环境后一定要删除解压后的文件重新解压编译,不然会出错 编译完成后,src目录中就会出现这些可执行文件就说明你的redis服务器安装成功了 2、配置redis主服务器redis的配置文件是存放在根目录的redis.conf文件启动redis之前我们修改一些配置文件 1vim redis.conf 123456#bind 127.0.0.1 #注释此配置,允许该服务器所有IP都能访问到Redis服务port 6379 #Redis服务的端口,默认是6379。可不修改daemonize yes #以守护进程模式启动redis,这样启动之后reids就不会占用当前连接databases 16 #默认redis服务器的库数量requirepass "123456" #设置redis的访问密码masterauth "123456" #设置从服务器访问主服务器的访问密码 3、配置redis从服务器由于是单机多端口模拟多台服务器,所以需要将redis的文件夹拷贝两份 12cp -r redis-5.0.3 redis-6380cp -r redis-5.0.3 redis-6381 分别进入这两个文件夹进行配置文件修改 12cd redis-6380vim redis.conf 123456#bind 127.0.0.1 #注释此配置,允许该服务器所有IP都能访问到Redis服务port 6380 #Redis服务的端口,进入redis-6381文件夹时端口改为6381,确保端口不冲突daemonize yes #以守护进程模式启动redis,这样启动之后reids就不会占用当前连接requirepass "123456" #设置redis的访问密码masterauth "123456" #设置从服务器访问主服务器的访问密码replicaof 192.168.230.220 6379 #设置主服务器IP地址及端口 低版本的redis设置服务器的配置项是:slaveof 192.168.230.220 6379,经测试,高版本设置这个属性也可以正常连接 保存退出,然后在各个redis的根目录启动redis服务器 启动redis服务器就是执行src文件夹中redis-server.sh的可以执行文件进行启动,同时显式的指定配置文件 4、启动服务器启动主服务器 12cd redis-5.0.3src/redis-server redis.conf 启动两个从服务器 1234cd ../redis-6380src/redis-server redis.confcd ../redis-6381src/redis-server redis.conf 查看服务器启动情况 1ps -ef|grep redis 此时你的redis服务已经启动成功了,然后就可以用客户端进行连接了 接着执行客户端启动脚本,连接的时候利用-a指定密码,-p指定端口(如果是默认端口6379可不写) 1src/redis-cli -a 123456 -p 6379 当你看着这个的时候说明redis连接成功了,此时你可以在这里输入reids命令进行操作 因为客户端会占用当前连接,所以我们需要另开一个ssh连接进行从服务器的客户端连接 此时在主服务器客户端(也就是6379端口的服务器)中查看从服务器的连接情况 1info replication 此时说明两台从服务器已经连接上了主服务器了,当然你也可以在从服务器的客户端查看主服务器的情况 1info replication 123master_host:192.168.230.221 主服务器IPmaster_port:6379 主服务器端口master_link_status:up 主服务器是否在线(up为在线,down为离线) 此时redis服务器的读写分离环境已经搭建完成 主服务器读写测试 从服务器读测试,此时从服务器可以直接读取到在主服务器添加的数据, 而在从服务器添加数据,则会提示从服务器是只读的 5、准备Sentinel 哨兵服务器回到redis根目录的上一级,我的目录结构是:/usr/soft/redis/,redis目录用来存放各个redis服务器.所以回到redis目录拷贝 123cp -r redis-6379 redis-26379cp -r redis-6379 redis-26380cp -r redis-6379 redis-26381 最终你的redis文件夹应该有这六个文件,说明你的sentinel服务器已经准备好了.剩下的就是修改配置了 哨兵服务器用的配置文件和redis服务器不一样,哨兵服务器用的是sentinel.conf 依次cd进入各个文件夹修改配置文件 12cd redis-26379vim sentinel.conf 123456789port 26379 # 哨兵服务器端口# mymaster为redis主服务器别名,192.168.230.221为主服务器IP,6379为主服务器端口,2为哨兵切换主备投票的最低票# 数,计算公式为(哨兵服务器数量+1)/2sentinel monitor mymaster 192.168.230.221 6379 2sentinel auth-pass mymaster 123456 # mymaster为上面设置的别名,123456为连接主服务器需要的访问密码# sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换),则认为本次failover失败# 默认值为900000毫秒,可根据实际情况修改sentinel failover-timeout mymaster 900000sentinel down-after-milliseconds mymaster 30000 # sentinel认为redis服务器已经断线所需的毫秒数 配置到这里,基本上sentinel服务器已经配置好了,剩下的就是依次进入26380和26381文件夹修改对应的配置,注意更换端口,不然启动时会端口冲突 配置完成之后,启动就变得很简单了,由于没有配置sentinel的后台启动,所以每个服务器都会占用一个连接,就需要多开连接进行了 12cd /redis-26379src/redis-sentinel sentinel.conf 如果你能看到这个经典的启动界面,说明你的sentinel服务器已经启动了,你离成功也就差几个命令了 在新开的连接窗口,进入sentinel服务器根目录 12cd /usr/soft/redis/redis-26380src/redis-sentinel sentinel.conf 启动成功之后,你能看到启动界面,并且能打印之前我们启动的那台sentinel服务器信息,说明这台sentinel也已经启动成功了 并且之前启动的端口号为26379的那台sentinel服务器也会打印这台服务器信息 说明两天sentinel服务器已经正常监听了6379的redis主服务器,并且两台sentinel也建立了通信 如果新开的sentinel服务器显示redis主服务器离线,并且也没有打印26379的服务器信息,说明服务器的配置处理问题重点检查是否配置了redis主服务器的验证密码,redis主服务器的IP端口是否正确 剩下的就是按照以上步骤,启动端口为26381的sentinel服务器. 12cd /usr/soft/redis/redis-26381src/redis-sentinel sentinel.conf 如果你能在之前启动的两台服务器日志里看到26381的日志打印信息,说明服务器启动成功. 这时,你的Linux下的redis读写分离和高可用的环境已经搭建完成,当有主服务器宕机之后,sentinel服务器会自动选举出新的服务器并且进行切换,宕机的服务器重新上线后会自动作为从服务器加入集群环境.]]></content>
      <categories>
        <category>Java</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下的hexo+GitHub个人博客搭建]]></title>
    <url>%2Fp%2Fae3b3943%2F</url>
    <content type="text"><![CDATA[windows下的hexo+GitHub个人博客搭建1、node.js的下载与安装1)、下载node.js去node的官方网站下载windows版本的zip文件node.js的官方下载连接 下载后解压至任意目录 在解压后目录中新建两个文件夹(用来存放npm全局模块的安装目录,也可以指定其他目录 node-cachenode-global 2)、配置环境变量新建NODE_HOME12变量名:NODE_HOME变量值:C:\Java\node-v10.15.0-win-x64(路径为解压node后存放的根目录) 配置path12%NODE_HOME%%NODE_HOME%\node-global 1)、设置node打开cmd,输入命令设置node 12npm config set prefix "C:\Java\node-v10.15.0-win-x64\node-global"npm config set cache "C:\Java\node-v10.15.0-win-x64\node-cache" 此处地址为安装目录,根据你们实际情况修改 2)、设置npm国内源1npm config set registry "https://registry.npm.taobao.org" 3)、测试node是否安装成功12node -vnpm -v 1234C:\Users\siworae&gt;node -vv10.15.0C:\Users\siworae&gt;npm -v6.4.1 出现这个则说明安装成功 2、安装gitgit下载地址:https://www.git-scm.com/download/ 去git官网下载相对于的版本进行安装 安装成功后可以通过git –version测试是否安装成功 12C:\Users\siworae&gt;git --versiongit version 2.10.2.windows.1 3、注册GitHub账号和创建GitHub仓库在GitHub官网注册GitHub账号 1)、创建仓库 创建git仓库时候，仓库的名称有格式要求，例如我的GitHub仓库用户名是siworae,仓库名称就是siworae.github.io 然后点击下面的create repository就可以成功创建GitHub仓库了,创建完之后会跳转到一个新的界面,不要关闭.留着它 4、安装hexohexo官方中文文档:https://hexo.io/zh-cn/docs/index.html hexo中的命令介绍 1234hexo g #完整命令为hexo generate，用于生成静态文件 hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览 hexo d #完整命令为hexo deploy，用于将本地文件发布到github上 hexo n #完整命令为hexo new，用于新建一篇文章 在任意目录新建hexo文件夹(名字任意),我在C盘中新建了一个hexo文件夹,进入这个文件夹,鼠标右键选择”Git Bash here”进入git命令行窗口,执行以下命令设施node、安装hexo和git依赖.之后所有的操作都需要在这个目录下完成 1)、初始化hexo1hexo init 2)、安装文中所有路径都尽量不要包含中文路径,不然很容易出现各种稀奇古怪的错误 12npm install hexo-cli -gnpm install hexo-deployer-git --save 3)、安装依赖1npm insatll 4)、生成静态文件1hexo g 启动本地服务,就可以进行本地预览了,启动之后这个窗口不能关闭,不然博客无法访问 1hexo s 这个时候我们就可以在浏览器输入:http://127.0.0.1:4000进行访问我们的博客了,但是此时博客还是只在我们本地上,想要在外网可以访问还需要将博客发布到GitHub上 5、部署本地网站到GitHub1)、设置GitHub和git首先,需要将你的git连接上你的GitHub 在Git Bash here命令行窗口输入GitHub中设置的用户名和关联邮箱进行本地git设置 12git config --global user.name "your name" git config --global user.email your_email@youremail.com 在本机上生成ssh的密钥用于GitHub登陆(your_email@youremail.com改为自己在GitHub绑定的邮箱) 1ssh-keygen -t rsa -C your_email@youremail.com 然后一路回车,系统会自动将生成的公钥和私钥文件保存在C:\Users\siworae.ssh文件夹里面(siworae为自己的电脑用户名) .ssh为隐藏文件夹,需要开启显示隐藏文件才能看到 在文件夹里面找到id_rsa.pub文件,用记事本或者notepad打开,复制. 打开GitHub登陆,点击settings 在SSH Keys/Add new界面中,title填写标题,可随意,key一栏填写刚刚复制的id_rsa.pub文件里面的内容.点击页面下面的Add SSH key就添加成功了 2)、配置hexo配置文件在hexo安装根目录下找到_config.yml文件. 用记事本或者notepad打开,在最后面添加GitHub的信息 注意在hexo所有的配置文件中,冒号后面都需要跟一个空格,不然会报错 repository填写你的仓库地址,在创建完仓库之后就会跳转到这个界面,选择SSH.复制路径 1234deploy: type: git repository: git@github.com:siworae/siworae.github.io.git branch: master 这个时候你的GitHub已经和hexo关联起来了 12hexo ghexo d 将本地代码推送到GitHub上,然后你可以到GitHub仓库看看代码是否已经推送成功.成功之后你就可以通过siworaer.GitHub.io网址来访问自己的博客了 6、主题安装进入hexo目录.打开git命令行窗口,执行以下命令将主题文件下载至hexo/themes目录,这里我已安装BlueLake主题为例,具体主题可以到官网下载https://hexo.io/themes/ 1git clone https://github.com/chaooo/hexo-theme-BlueLake.git hexo安装根目录下找到_config.yml文件,将landscape改为BlueLake 12#theme: landscapetheme: BlueLake 清除缓存并重新生成静态文件 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 打开浏览器就可以查看新的主题效果了 具体的主题设置可以参照官方文档https://github.com/chaooo/hexo-theme-BlueLake#bluelake 7、修改站点配置信息hexo安装根目录下找到_config.yml文件 1)、设置语言 1language: zh-CN 2)、设置个人信息 12345title: ##标题subtitle: ##副标题description: ##简要描述keywords: ##关键字author: ##作者信息 然后重新推送到GitHub上,然后你的个人博客基本上就大功告成了. 8、安装问题中出现的问题如果安装hexo后出现bash: hexo: command not found,将hexo安装目录下的…\node_modules\hexo\bin配置到path环境变量中]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
